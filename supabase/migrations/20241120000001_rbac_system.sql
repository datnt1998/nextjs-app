-- =====================================================
-- RBAC System Following Supabase Official Pattern
-- https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac
-- =====================================================

-- 1. CREATE CUSTOM TYPES FOR ROLES AND PERMISSIONS
-- =====================================================

create type public.app_role as enum ('owner', 'admin', 'manager', 'editor', 'viewer');

create type public.app_permission as enum (
  -- User permissions
  'users:view',
  'users:create',
  'users:update',
  'users:delete',
  -- Item permissions
  'items:view',
  'items:create',
  'items:update',
  'items:delete',
  -- Settings permissions
  'settings:view',
  'settings:update',
  -- Analytics permissions
  'analytics:view'
);

-- 2. CREATE USER ROLES TABLE
-- =====================================================
-- Links users to their roles (supports multiple roles per user)

create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  role public.app_role not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (user_id, role)
);

comment on table public.user_roles is 'Application roles for each user.';

-- Create index for faster lookups
create index user_roles_user_id_idx on public.user_roles(user_id);

-- Enable RLS
alter table public.user_roles enable row level security;

-- 3. CREATE ROLE PERMISSIONS TABLE
-- =====================================================
-- Maps roles to their permissions

create table public.role_permissions (
  id bigint generated by default as identity primary key,
  role public.app_role not null,
  permission public.app_permission not null,
  unique (role, permission)
);

comment on table public.role_permissions is 'Application permissions for each role.';

-- Enable RLS
alter table public.role_permissions enable row level security;

-- 4. POPULATE ROLE PERMISSIONS
-- =====================================================
-- Define what each role can do

insert into public.role_permissions (role, permission) values
  -- Owner: Full access to everything
  ('owner', 'users:view'),
  ('owner', 'users:create'),
  ('owner', 'users:update'),
  ('owner', 'users:delete'),
  ('owner', 'items:view'),
  ('owner', 'items:create'),
  ('owner', 'items:update'),
  ('owner', 'items:delete'),
  ('owner', 'settings:view'),
  ('owner', 'settings:update'),
  ('owner', 'analytics:view'),

  -- Admin: All permissions except user delete
  ('admin', 'users:view'),
  ('admin', 'users:create'),
  ('admin', 'users:update'),
  ('admin', 'items:view'),
  ('admin', 'items:create'),
  ('admin', 'items:update'),
  ('admin', 'items:delete'),
  ('admin', 'settings:view'),
  ('admin', 'settings:update'),
  ('admin', 'analytics:view'),

  -- Manager: View users, full items access, view analytics
  ('manager', 'users:view'),
  ('manager', 'items:view'),
  ('manager', 'items:create'),
  ('manager', 'items:update'),
  ('manager', 'items:delete'),
  ('manager', 'settings:view'),
  ('manager', 'analytics:view'),

  -- Editor: Create and edit items, view settings
  ('editor', 'items:view'),
  ('editor', 'items:create'),
  ('editor', 'items:update'),
  ('editor', 'settings:view'),

  -- Viewer: Read-only access
  ('viewer', 'items:view'),
  ('viewer', 'settings:view');

-- 5. CREATE PROFILES TABLE (Basic User Info)
-- =====================================================
-- Stores user profile information (separate from RBAC)

create table public.profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  full_name text,
  avatar_url text,
  tenant_id text not null default 'default',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.profiles is 'User profiles with basic information.';

-- Enable RLS
alter table public.profiles enable row level security;

-- Create index
create index profiles_tenant_id_idx on public.profiles(tenant_id);

-- 6. CREATE ITEMS TABLE (Demo CRUD Table)
-- =====================================================

create table public.items (
  id uuid default gen_random_uuid() primary key,
  title text not null,
  description text,
  status text not null default 'draft' check (status in ('draft', 'published', 'archived')),
  image_url text,
  user_id uuid references auth.users(id) on delete cascade not null,
  tenant_id text not null default 'default',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.items is 'Demo items table for CRUD operations.';

-- Enable RLS
alter table public.items enable row level security;

-- Create indexes
create index items_user_id_idx on public.items(user_id);
create index items_tenant_id_idx on public.items(tenant_id);
create index items_status_idx on public.items(status);

-- 7. CREATE CUSTOM ACCESS TOKEN HOOK
-- =====================================================
-- This is the key function that injects user_role into JWT
-- Following Supabase's official pattern exactly

create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
declare
  claims jsonb;
  user_role public.app_role;
  user_tenant text;
begin
  -- Fetch the user's primary role from user_roles table
  select role into user_role
  from public.user_roles
  where user_id = (event->>'user_id')::uuid
  limit 1;

  -- Fetch the user's tenant_id from profiles table
  select tenant_id into user_tenant
  from public.profiles
  where id = (event->>'user_id')::uuid;

  -- Get existing claims
  claims := event->'claims';

  -- Set the user_role claim (required)
  if user_role is not null then
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  else
    -- Default to viewer if no role assigned
    claims := jsonb_set(claims, '{user_role}', '"viewer"');
  end if;

  -- Set the tenant_id claim (optional but recommended for multi-tenancy)
  if user_tenant is not null then
    claims := jsonb_set(claims, '{tenant_id}', to_jsonb(user_tenant));
  else
    claims := jsonb_set(claims, '{tenant_id}', '"default"');
  end if;

  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);

  -- Return the modified event
  return event;
end;
$$;

-- Grant necessary permissions to supabase_auth_admin
grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;

-- Grant supabase_auth_admin access to read from tables used in the hook
grant all on table public.user_roles to supabase_auth_admin;
grant all on table public.profiles to supabase_auth_admin;

revoke all on table public.user_roles from authenticated, anon, public;

-- 8. CREATE AUTHORIZE FUNCTION FOR RLS
-- =====================================================
-- Helper function to check permissions in RLS policies

create or replace function public.authorize(
  requested_permission public.app_permission
)
returns boolean as $$
declare
  bind_permissions int;
  user_role public.app_role;
begin
  -- Fetch user role from JWT claims (injected by auth hook)
  select (auth.jwt() ->> 'user_role')::public.app_role into user_role;

  -- Check if the user's role has the requested permission
  select count(*)
  into bind_permissions
  from public.role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = user_role;

  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';

-- 9. CREATE TRIGGER TO AUTO-ASSIGN DEFAULT ROLE
-- =====================================================
-- Automatically create profile and assign 'viewer' role to new users

create or replace function public.handle_new_user()
returns trigger as $$
begin
  -- Create profile
  insert into public.profiles (id, email, full_name, tenant_id)
  values (
    new.id,
    new.email,
    new.raw_user_meta_data->>'full_name',
    coalesce(new.raw_user_meta_data->>'tenant_id', 'default')
  );

  -- Assign default 'viewer' role
  -- NOTE: Never trust client-provided role - always server-controlled
  insert into public.user_roles (user_id, role)
  values (new.id, 'viewer');

  return new;
end;
$$ language plpgsql security definer;

-- Create trigger
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

-- 10. RLS POLICIES FOR role_permissions TABLE
-- =====================================================
-- Allow authenticated users to read role permissions (so they can check their own)

create policy "Allow authenticated users to read role permissions"
  on public.role_permissions
  for select
  to authenticated
  using (true);

-- Allow auth admin to read (for the hook)
create policy "Allow auth admin to read role permissions"
  on public.role_permissions
  as permissive for select
  to supabase_auth_admin
  using (true);

-- 11. RLS POLICIES FOR user_roles TABLE
-- =====================================================
-- Users can view their own roles

create policy "Users can view own roles"
  on public.user_roles
  for select
  to authenticated
  using (auth.uid() = user_id);

-- Allow auth admin to read (for the hook)
create policy "Allow auth admin to read user roles"
  on public.user_roles
  as permissive for select
  to supabase_auth_admin
  using (true);

-- Only owners can manage user roles
create policy "Only owners can insert user roles"
  on public.user_roles
  for insert
  to authenticated
  with check (authorize('users:create'));

create policy "Only owners can update user roles"
  on public.user_roles
  for update
  to authenticated
  using (authorize('users:update'));

create policy "Only owners can delete user roles"
  on public.user_roles
  for delete
  to authenticated
  using (authorize('users:delete'));

-- 12. RLS POLICIES FOR profiles TABLE
-- =====================================================

-- Users can view own profile
create policy "Users can view own profile"
  on public.profiles
  for select
  to authenticated
  using (auth.uid() = id);

-- Users with users:view can see all profiles in their tenant
create policy "Users with permission can view profiles in tenant"
  on public.profiles
  for select
  to authenticated
  using (
    authorize('users:view')
    and tenant_id = (auth.jwt() ->> 'tenant_id')
  );

-- Users can update own profile
create policy "Users can update own profile"
  on public.profiles
  for update
  to authenticated
  using (auth.uid() = id);

-- Allow auth admin to read (for the hook)
create policy "Allow auth admin to read profiles"
  on public.profiles
  as permissive for select
  to supabase_auth_admin
  using (true);

-- 13. RLS POLICIES FOR items TABLE
-- =====================================================

-- Anyone with items:view can see items in their tenant
create policy "View items with permission"
  on public.items
  for select
  to authenticated
  using (
    authorize('items:view'::app_permission)
    and tenant_id = (auth.jwt() ->> 'tenant_id')
  );

-- Anyone with items:create can create items
create policy "Create items with permission"
  on public.items
  for insert
  to authenticated
  with check (
    authorize('items:create'::app_permission)
    and tenant_id = (auth.jwt() ->> 'tenant_id')
    and auth.uid() = user_id
  );

-- Users can update their own items, or anyone with items:update
create policy "Update items with permission"
  on public.items
  for update
  to authenticated
  using (
    (auth.uid() = user_id or authorize('items:update'::app_permission))
    and tenant_id = (auth.jwt() ->> 'tenant_id')
  );

-- Users can delete their own items, or anyone with items:delete
create policy "Delete items with permission"
  on public.items
  for delete
  to authenticated
  using (
    (auth.uid() = user_id or authorize('items:delete'::app_permission))
    and tenant_id = (auth.jwt() ->> 'tenant_id')
  );

-- =====================================================
-- 14. HELPER FUNCTION TO CREATE USERS WITH ROLES
-- =====================================================
-- This function allows easy creation of users with specific roles
-- Useful for bootstrapping admin accounts and testing

create or replace function public.create_user_with_role(
  user_email text,
  user_password text,
  user_full_name text,
  user_role app_role default 'viewer',
  user_tenant_id text default 'default'
)
returns table(user_id uuid, email text, role app_role) as $$
declare
  new_user_id uuid;
begin
  -- Create the auth user with encrypted password
  insert into auth.users (
    instance_id,
    id,
    aud,
    role,
    email,
    encrypted_password,
    email_confirmed_at,
    raw_user_meta_data,
    created_at,
    updated_at,
    confirmation_token,
    email_change,
    email_change_token_new,
    recovery_token
  ) values (
    '00000000-0000-0000-0000-000000000000',
    gen_random_uuid(),
    'authenticated',
    'authenticated',
    user_email,
    crypt(user_password, gen_salt('bf')),
    now(), -- Auto-confirm email
    jsonb_build_object('full_name', user_full_name),
    now(),
    now(),
    '',
    '',
    '',
    ''
  )
  returning id into new_user_id;

  -- Create profile (handle_new_user trigger should do this, but ensure it exists)
  insert into public.profiles (id, email, full_name, tenant_id)
  values (new_user_id, user_email, user_full_name, user_tenant_id)
  on conflict (id) do nothing;

  -- If a different role than viewer is specified, update it
  if user_role != 'viewer' then
    -- Remove the default viewer role assigned by trigger
    delete from public.user_roles where user_roles.user_id = new_user_id;

    -- Assign the specified role
    insert into public.user_roles (user_id, role)
    values (new_user_id, user_role);
  end if;

  -- Return user info
  return query
  select new_user_id, user_email, user_role;
end;
$$ language plpgsql security definer;

-- Grant execute permission
grant execute on function public.create_user_with_role to postgres, authenticated;

comment on function public.create_user_with_role is 'Creates a new user with specified role and auto-confirms their email';

-- =====================================================
-- USAGE EXAMPLES
-- =====================================================
-- Create a super admin (owner):
-- SELECT * FROM create_user_with_role('admin@example.com', 'secure-password', 'Admin User', 'owner');
--
-- Create an editor:
-- SELECT * FROM create_user_with_role('editor@example.com', 'password123', 'Editor User', 'editor');
--
-- Create a viewer (default role):
-- SELECT * FROM create_user_with_role('viewer@example.com', 'password123', 'Viewer User');
--
-- Create user in specific tenant:
-- SELECT * FROM create_user_with_role('user@company.com', 'password123', 'User', 'manager', 'company-id');
-- =====================================================

-- =====================================================
-- MIGRATION COMPLETE
-- =====================================================
-- Next steps:
-- 1. Enable the Auth Hook in Supabase Dashboard:
--    Authentication > Hooks (Beta) > Custom Access Token
--    Select: public.custom_access_token_hook
--
-- 2. Test with a new signup to verify JWT contains user_role
--
-- 3. Create your first super admin:
--    SELECT * FROM create_user_with_role('admin@example.com', 'your-password', 'Super Admin', 'owner');
--
-- 4. Update application code to decode JWT and read user_role
-- =====================================================
